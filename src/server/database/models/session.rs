// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]

use chrono::offset::Utc;
use chrono::DateTime;
use diesel::{
    dsl::exists,
    expression::AsExpression,
    query_dsl::methods::{FilterDsl, SelectDsl},
    select, Expression, ExpressionMethods, OptionalExtension, Queryable, Selectable,
};
use diesel_async::{AsyncConnection, RunQueryDsl};
use serde::Serialize;
use tap::Pipe;
use tower_sessions::session::{Id, Record};
use tracing_subscriber::registry::Data;

use crate::server::database::connection::DatabaseConnection;
use crate::server::database::schema;

#[derive(Selectable, Queryable, Debug)]
#[diesel(table_name = schema::session)]
pub struct Session {
    pub id: String,
    pub data: serde_json::Value,
    pub expiry_date: DateTime<Utc>,
}

pub async fn session_exists(
    conn: &mut DatabaseConnection,
    id: &str,
) -> Result<bool, diesel::result::Error> {
    use schema::session::id as q_id;
    use schema::session::table;

    select(exists(table.filter(q_id.eq(id))))
        .get_result::<bool>(conn)
        .await
}

pub async fn load_session(
    conn: &mut DatabaseConnection,
    id: &str,
) -> Result<Option<Session>, diesel::result::Error> {
    use schema::session::table;

    table
        .filter(schema::session::id.eq(id))
        .filter(schema::session::expiry_date.gt(Utc::now()))
        .get_result(conn)
        .await
        .optional()?
        .pipe(Ok)
}

pub async fn create_session(
    conn: &mut DatabaseConnection,
    id: &str,
    data: serde_json::Value,
    expiry_date: DateTime<Utc>,
) -> Result<(), diesel::result::Error> {
    use schema::session::table;
    use schema::session::{data as q_data, expiry_date as q_expiry_date, id as q_id};

    diesel::insert_into(table)
        .values((q_id.eq(id), q_data.eq(data), q_expiry_date.eq(expiry_date)))
        .execute(conn)
        .await?;

    Ok(())
}

pub async fn delete_expired(conn: &mut DatabaseConnection) -> Result<(), diesel::result::Error> {
    use schema::session::expiry_date;
    use schema::session::table;

    diesel::delete(table.filter(expiry_date.lt(Utc::now())))
        .execute(conn)
        .await?;

    Ok(())
}

pub async fn delete_session(
    conn: &mut DatabaseConnection,
    id: &str,
) -> Result<(), diesel::result::Error> {
    use schema::session::id as q_id;
    use schema::session::table;

    diesel::delete(table.filter(q_id.eq(id)))
        .execute(conn)
        .await?;

    Ok(())
}
